/* Everything to do with naming, storage, and lookup */

// to replace CleanSoundLibrary

CleanLibrary : CleanEvent {
	// var <server, <numChannels;
	var <>defaultEvent; // move to CleanEvent
	var <>verbose = false; // move to SuperClean

	var <>fileExtensions = #["wav", "aif", "aiff", "aifc"];

	var <samples, <buffers, <pairedSamples, <samplePlayers; // are these last three actually necessary?;
	var <modules, <soundSources, <midiDevices, <instanceEffects, <globalEffects; // are these last four actually necessary?;
	var <buses, <audio, <modulation; // are these last two actually necessary?
	var <instances, <cutGroups; // is this last one actually necessary?
	var <namespace, <sources, <effects, <routing; // are these last three actually nec?

	var <>instanceEffectsOrder;


	*new { |server, numChannels|
		^super.newCopyArgs(server, numChannels).init
	}


	/* Create collections to store samples, sound sources, effects, routing, etc which will be accessed by SuperClean */
	init {
		samples = IdentityDictionary.new(know: true); // Store all things pertaining to audio files
		samples.put(\buffers, IdentityDictionary.new(know: true)); // Buffers allocated to loaded audio files
		samples.put(\pairedSamples, IdentityDictionary.new(know: true)); // Allocated sample players to handle specific buffer (file) playback
		samples.put(\samplePlayers, IdentityDictionary.new(know: true)); // Name of SynthDefs and paramenter/key translations of sample player SynthDefs
		// or modules.samplePlayers for better consistency?


		modules = IdentityDictionary.new(know: true); // Store all things pertaining to non-sample based sound creation and manipulation
		modules.put(\soundSources, IdentityDictionary.new(know: true)); // Name and parameter/key translations of (non-sample) signal generating SynthDefs
		// modules.soundSources.put(\synths, IdentityDictionary.new(know: true));
		// modules.soundSources.put(\inputs, IdentityDictionary.new(know: true));
		// modules.soundSources.put(\samples, IdentityDictionary.new(know: true));
		// modules.soundSources.samples.put(\buffers, IdentityDictionary.new(know: true));
		// modules.soundSources.samples.buffers.put(\pairedSamples, IdentityDictionary.new(know: true));
		modules.put(\midiDevices, IdentityDictionary.new(know: true)); // Name and parameter/key translations of output MIDI control data
		modules.put(\instanceEffects, IdentityDictionary.new(know: true)); // Name and parameter/key translations of (per-step event/pattern) instance effects
		modules.instanceEffects.put(\order, List.new); // Signal-chain order of (per-step event/pattern) instance effects
		modules.put(\globalEffects, IdentityDictionary.new(know: true)); // Name and parameter/key translations of (always running & shared per-aux) global effects
		modules.globalEffects.put(\order, List.new); // Signal-chain order of global effects

		buses = IdentityDictionary.new(know: true); // Store all things pertaining to signal bus routing
		buses.put(\audio, IdentityDictionary.new(know: true)); // Audio-rate buses
		// buses.audio.put(\routingBus // Buses allocated for internal audio-rate signal routing
		// buses.audio.put(\instanceBus // Buses allocated for audio signals generated by per-step patterns/events, summed in \clean_instanceSumBus
		// buses.audio.put(\globalDryBus // Buses allocated for routing summed instance audio signals into global effects
		// buses.audio.put(\globalWetBus // Buses allocated for routing post-global effect audio signals
		// buses.audio.put(\outputBus // Buses allocated for monitoring and recording outputs
		buses.put(\modulation, IdentityDictionary.new(know: true)); // Control-rate buses

		instances = IdentityDictionary.new(know: true); // Store all things pertaining to per-step event pattern instances
		instances.put(\cutGroups, IdentityDictionary.new(know: true)); // Per-step event/pattern sound-source cut group allocations

		namespace = IdentityDictionary.new(know: true); // Group like dictionaries together to allow for namespace checking
		namespace.put(\sources, IdentityDictionary.new(know: true));
		namespace.put(\effects, IdentityDictionary.new(know: true));
		namespace.put(\routing, IdentityDictionary.new(know: true));
	}




	/* Add X to relevant IdentityDictionary */

	// Performs all of the prep and collating of module name, bundled parameters, and other relevant data for storage in a dictionary
	// Only necessary if not using classes for modules? Eg- should the classes actually do all this?
	// Only necessary if not using classes for modules? Eg- should the classes actually do all this?
	// Only necessary if not using classes for modules? Eg- should the classes actually do all this?
	prepModule { |cName, sdName, params, type, nSpace, exclNS, /*spawnTest, orderedMod, modPos,*/ desc|
		// cName == module name
		// sdName == SynthDef name
		// params == bundled SynthDef args, and SuperClean key conversions: should be an Event
		// type == dictionary name, supplied by specific addX method
		// nSpace == namespace grouping to check for naming overlap
		// exclNS == excluded dictionary from namespace overlap lookup (this module type's dict name)
		// spawnTest == boolean under test whether to spawn Synth or not (for instance effects)
		// orderedMod == boolean whether module should be ordered (for instance effects)
		// modPos == which slot to insert ordered module
		// desc == description of module and its parameters, for verbose posting
		var metadata;

		// If a different module in another dictionary already has the same name, throw an error
		if(this.overlappingNamespaceChecker(nSpace, exclNS, cName)) {
			"\nA source named '%' already exists. \nSkipping... Please rename.\n".format(cName).warn;
			^this
		};

		metadata = [
			instrument: sdName,
			hash: sdName.identityHash,
			description: desc
		].asDict;

		/*// If the order of modules is important (eg Instance Effects):
		// Move to relevant add* methods?
		// Move to relevant add* methods?
		// Move to relevant add* methods?
		if(orderedModule) {
			this.orderModule(type, cName, modPos);
		};*/

		// If module already exists, it will be replaced
		if(type[cName].notNil) {
			"\nReplacing '%: %' with new version.\n".postf(cName, sdName);
			type[cName] = nil
		};

		// Create dictionary entry, and store module data in appropriate sections
		type.put(cName, IdentityDictionary.new(know: true));
		type[cName].put(\parameters, params);
		type[cName].put(\metadata, metadata);

		if(desc.notNil and: { verbose }) {
			"%\n".postf(desc)
		};
	}


	addSample {

	}


	addSamplePlayer {

	}


	addSoundSource { |cleanName, synthDefName, parameters, description = nil|
		var type = modules.soundSources; // Dictionary to add module to
		var nSpace = namespace.sources; // Namespace grouping to check for naming overlap
		var exclNS = \soundSources; // Exclude dictionary from namespace overlap lookup
		var cName = cleanName.asSymbol; // Module name
		var sdName = synthDefName.asSymbol; // SynthDef name

		this.prepModule(cName, sdName, parameters, type, nSpace, exclNS, description);

		// Select the appropriate module type, and provide it with all relevant data
		//
		// module = CleanSourceModule(cName, sdName, parameters); // add arg values like this, or with reference to library?
		// module = CleanSourceModule(type[cName], type[cName][\metadata][\instrument], type[cName][\parameters])
	}


	addMIDI {

	}


	addInstanceEffect { |cleanName, synthDefName, parameters, modulePosition, description = nil|
		var type = modules.instanceEffects; // Dictionary to add module to
		var nSpace = namespace.effects; // Namespace grouping to check for naming overlap
		var exclNS = \instanceEffects; // Exclude dictionary from namespace overlap lookup
		var cName = cleanName.asSymbol; // Module name
		var sdName = synthDefName.asSymbol; // SynthDef name

		this.prepModule(cName, sdName, parameters, type, nSpace, exclNS, description);

		// Place module in specified signal chain location
		this.orderModule(type, cName, modulePosition);

		// Modules are ultimately what spawn synths
		// module = CleanInstanceModule(cName, sdName, parameters); // add arg values like this, or with reference to library?
		// module = CleanSourceModule(type[cName], type[cName][\metadata][\instrument], type[cName][\parameters])
	}


	addGlobalEffect { |cleanName, synthDefName, parameters, modulePosition, description = nil|
		var type = modules.globalEffects; // Dictionary to add module to
		var nSpace = namespace.effects; // Namespace grouping to check for naming overlap
		var exclNS = \globalEffects; // Exclude dictionary from namespace overlap lookup
		var cName = cleanName.asSymbol; // Module name
		var sdName = synthDefName.asSymbol; // SynthDef name

		this.prepModule(cName, sdName, parameters, type, nSpace, exclNS, description);

		// Place module in specified signal chain location
		this.orderModule(type, cName, modulePosition);

		//
		// module = CleanGlobalModule(cName, sDefName, parameters); // add arg values like this, or with reference to library?
		// module = CleanSourceModule(type[cName], type[cName][\metadata][\instrument], type[cName][\parameters])
	}




	/* Pair parameter with appropriate SynthDefs */

	allocSamplePlayer { // formerly: pairBufferWithSamplePlayer

	}




	/* Organize and sort */

	orderModule { |type, name, position|
		// type == dictionary name
		// name == module name
		// position == which slot to insert ordered module
		var order = type[\order];
		var currentPos = order.indexOf(name);

		if(order.isNil) {
			// If ordering this type of module is not possible, return an error and cancel out
			Error("It is not possible to place this type of module in a specific order. Check -add* method type.").throw
			^this
		} {
			if(currentPos.notNil) {
				// If the module already had a position, remove it from its original location, just in case
				order.removeAt(currentPos);

				// Move to new location, if provided, else put it back where it was
				order.insert(position ?? { currentPos }, name);
				^"'%' repositioned in the signal chain.\n The current order is: '%'".format(name, order.asArray).postln
			} {
				// If the module is new, place it where specified, or else add it to the end
				order.insert(position ?? { order.size }, name);
				^"'%' added to the signal chain.\n The current order is: %".format(name, order.asArray).postln
			}
		}
	}


	/*
	LIKELY UNNECESSARY
	typeSelector { |type|
		^switch(type,
			\buffer, { samples.buffers },
			\buffers, { samples.buffers },
			\samplePlayer, { samples.samplePlayers },
			\samplePlayers, { samples.samplePlayers },
			\source, { modules.soundSources },
			\sources, { modules.soundSources },
			\soundSource, { modules.soundSources },
			\soundSources, { modules.soundSources },
			\midi, { modules.midiDevices },
			\midiDevice, { modules.midiDevices },
			\midiDevices, { modules.midiDevices },
			\instanceEffect, { modules.instanceEffects },
			\instanceEffects, { modules.instanceEffects },
			\globalEffect, { modules.globalEffects },
			\globalEffects, { modules.globalEffects },
			{ "Module type not found. Please check the name and try again.\n".postln }
		)
	}

	typeModuleSelector { |type, args|
		^switch(type,
			\buffers, { /**/ },
			\samplePlayers, { CleanSourceModule(args[0], args[1]/* etc */) },
			\soundSources, { CleanSourceModule(args[0], args[1]/* etc */) },
			\midiDevices, { CleanMIDIModule(args[0], args[1]/* etc */) },
			\instanceEffects, { CleanInstanceModule(args[0], args[1], args[2], args[3]) },
			\globalEffects, { CleanGlobalModule(args[0], args[1]/* etc */) },
			{ "Module type not found. Please check the name and try again.\n".postln }
		)
	}

	namespaceGrouper { |list|
		var namesDict = list.keysDo { |module|
			module
		};
		^namesDict
	}
	*/




	/* Namespace Checker */

	overlappingNamespaceChecker { |dict, exclude, name|
		var col = IdentityDictionary.newFrom(dict);
		var result;
		if(dict.includesKey(exclude)) {
			col.removeAt(exclude)
		};
		col = col.asArray;
		result = col.size.collect { |i| col[i].includesKey(name) };
		^result.includes(true)
	}

}
	